{"ast":null,"code":"import _regeneratorRuntime from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/*\n *  Copyright (c) 2018-present, Evgeny Nadymov\n *\n * This source code is licensed under the GPL v.3.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { arrayBufferToBase64, isAuthorizationReady } from './Utils/Common';\nimport { OPTIMIZATIONS_FIRST_START } from './Constants';\nimport ApplicationStore from './Stores/ApplicationStore';\nimport NotificationStore from './Stores/NotificationStore';\nimport TdLibController from './Controllers/TdLibController'; // In production, we register a service worker to serve assets from local cache.\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nvar isLocalhost = //false;\nBoolean(window.location.hostname === 'localhost' || // [::1] is the IPv6 localhost address.\nwindow.location.hostname === '[::1]' || // 127.0.0.1/8 is considered localhost for IPv4.\nwindow.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));\nexport default function register() {\n  return _register.apply(this, arguments);\n}\n\nfunction _register() {\n  _register = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var publicUrl, serviceWorkerName, swUrl;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            console.log('[SW] Register');\n\n            if (OPTIMIZATIONS_FIRST_START) {\n              localStorage.setItem('register', 'true');\n            }\n\n            if (!('serviceWorker' in navigator)) {\n              _context.next = 16;\n              break;\n            }\n\n            // The URL constructor is available in all browsers that support SW.\n            publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n\n            if (!(publicUrl.origin !== window.location.origin)) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 6:\n            serviceWorkerName = process.env.NODE_ENV === 'production' ? 'service-worker.js' : 'custom-service-worker.js';\n            swUrl = \"\".concat(process.env.PUBLIC_URL, \"/\").concat(serviceWorkerName);\n            console.log(\"[SW] Service worker url: \".concat(swUrl));\n\n            if (isLocalhost) {\n              _context.next = 14;\n              break;\n            }\n\n            _context.next = 12;\n            return registerValidSW(swUrl);\n\n          case 12:\n            _context.next = 16;\n            break;\n\n          case 14:\n            _context.next = 16;\n            return checkValidServiceWorker(swUrl);\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _register.apply(this, arguments);\n}\n\nfunction registerValidSW(_x) {\n  return _registerValidSW.apply(this, arguments);\n}\n\nfunction _registerValidSW() {\n  _registerValidSW = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(swUrl) {\n    var registration;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            console.log('[SW] RegisterValidSW');\n            _context2.prev = 1;\n            _context2.next = 4;\n            return navigator.serviceWorker.register(swUrl);\n\n          case 4:\n            registration = _context2.sent;\n\n            registration.onupdatefound = function () {\n              var installingWorker = registration.installing;\n\n              installingWorker.onstatechange = function () {\n                if (installingWorker.state === 'installed') {\n                  if (navigator.serviceWorker.controller) {\n                    // At this point, the old content will have been purged and\n                    // the fresh content will have been added to the cache.\n                    // It's the perfect time to display a \"New content is\n                    // available; please refresh.\" message in your web app.\n                    console.log('[SW] New content is available; please refresh.');\n                    TdLibController.clientUpdate({\n                      '@type': 'clientUpdateNewContentAvailable'\n                    });\n                  } else {\n                    // At this point, everything has been precached.\n                    // It's the perfect time to display a\n                    // \"Content is cached for offline use.\" message.\n                    console.log('[SW] Content is cached for offline use.');\n                  }\n                }\n              };\n            };\n\n            _context2.next = 11;\n            break;\n\n          case 8:\n            _context2.prev = 8;\n            _context2.t0 = _context2[\"catch\"](1);\n            console.error('[SW] Error during service worker registration: ', _context2.t0);\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[1, 8]]);\n  }));\n  return _registerValidSW.apply(this, arguments);\n}\n\nexport function subscribeNotifications() {\n  return _subscribeNotifications.apply(this, arguments);\n}\n\nfunction _subscribeNotifications() {\n  _subscribeNotifications = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3() {\n    var registration, pushSubscription, _pushSubscription, endpoint, p256dh_base64url, auth_base64url, authorizationState, deviceToken, result;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            _context3.next = 3;\n            return navigator.serviceWorker.ready;\n\n          case 3:\n            registration = _context3.sent;\n            _context3.next = 6;\n            return registration.pushManager.getSubscription();\n\n          case 6:\n            pushSubscription = _context3.sent;\n\n            if (!pushSubscription) {\n              _context3.next = 10;\n              break;\n            }\n\n            _context3.next = 10;\n            return pushSubscription.unsubscribe();\n\n          case 10:\n            _context3.next = 12;\n            return registration.pushManager.subscribe({\n              userVisibleOnly: true\n            });\n\n          case 12:\n            pushSubscription = _context3.sent;\n            console.log('[SW] Received push subscription: ', JSON.stringify(pushSubscription));\n            _pushSubscription = pushSubscription, endpoint = _pushSubscription.endpoint;\n            p256dh_base64url = arrayBufferToBase64(pushSubscription.getKey('p256dh'));\n            auth_base64url = arrayBufferToBase64(pushSubscription.getKey('auth'));\n\n            if (!(endpoint && p256dh_base64url && auth_base64url)) {\n              _context3.next = 26;\n              break;\n            }\n\n            authorizationState = ApplicationStore.authorizationState;\n\n            if (!isAuthorizationReady(authorizationState)) {\n              _context3.next = 26;\n              break;\n            }\n\n            deviceToken = {\n              '@type': 'deviceTokenWebPush',\n              endpoint: endpoint,\n              p256dh_base64url: p256dh_base64url,\n              auth_base64url: auth_base64url\n            };\n            console.log('[SW] registerDevice', deviceToken);\n            _context3.next = 24;\n            return TdLibController.send({\n              '@type': 'registerDevice',\n              device_token: deviceToken,\n              other_user_ids: []\n            });\n\n          case 24:\n            result = _context3.sent;\n            console.log('[SW] registerDevice result', result);\n\n          case 26:\n            _context3.next = 32;\n            break;\n\n          case 28:\n            _context3.prev = 28;\n            _context3.t0 = _context3[\"catch\"](0);\n            console.error('[SW] Error during service worker push subscription: ', _context3.t0);\n            NotificationStore.enableSound = true;\n\n          case 32:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[0, 28]]);\n  }));\n  return _subscribeNotifications.apply(this, arguments);\n}\n\nfunction checkValidServiceWorker(_x2) {\n  return _checkValidServiceWorker.apply(this, arguments);\n}\n\nfunction _checkValidServiceWorker() {\n  _checkValidServiceWorker = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4(swUrl) {\n    var response, registration;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            console.log('[SW] CheckValidServiceWorker'); // Check if the service worker can be found. If it can't reload the page.\n\n            _context4.prev = 1;\n            _context4.next = 4;\n            return fetch(swUrl);\n\n          case 4:\n            response = _context4.sent;\n\n            if (!(response.status === 404 || response.headers.get('content-type').indexOf('javascript') === -1)) {\n              _context4.next = 14;\n              break;\n            }\n\n            _context4.next = 8;\n            return navigator.serviceWorker.ready;\n\n          case 8:\n            registration = _context4.sent;\n            _context4.next = 11;\n            return registration.unregister();\n\n          case 11:\n            window.location.reload();\n            _context4.next = 16;\n            break;\n\n          case 14:\n            _context4.next = 16;\n            return registerValidSW(swUrl);\n\n          case 16:\n            _context4.next = 21;\n            break;\n\n          case 18:\n            _context4.prev = 18;\n            _context4.t0 = _context4[\"catch\"](1);\n            console.log('[SW] No internet connection found. App is running in offline mode.');\n\n          case 21:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[1, 18]]);\n  }));\n  return _checkValidServiceWorker.apply(this, arguments);\n}\n\nexport function unregister() {\n  return _unregister.apply(this, arguments);\n}\n\nfunction _unregister() {\n  _unregister = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee5() {\n    var registration;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            if (!('serviceWorker' in navigator)) {\n              _context5.next = 6;\n              break;\n            }\n\n            _context5.next = 3;\n            return navigator.serviceWorker.ready;\n\n          case 3:\n            registration = _context5.sent;\n            _context5.next = 6;\n            return registration.unregister();\n\n          case 6:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _unregister.apply(this, arguments);\n}\n\nexport function update() {\n  return _update.apply(this, arguments);\n}\n\nfunction _update() {\n  _update = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee6() {\n    var registration;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (!('serviceWorker' in navigator)) {\n              _context6.next = 6;\n              break;\n            }\n\n            _context6.next = 3;\n            return navigator.serviceWorker.ready;\n\n          case 3:\n            registration = _context6.sent;\n            _context6.next = 6;\n            return registration.update();\n\n          case 6:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _update.apply(this, arguments);\n}","map":{"version":3,"sources":["/Users/wubenqi/nebula-chat/telegram-react/src/registerServiceWorker.js"],"names":["arrayBufferToBase64","isAuthorizationReady","OPTIMIZATIONS_FIRST_START","ApplicationStore","NotificationStore","TdLibController","isLocalhost","Boolean","window","location","hostname","match","register","console","log","localStorage","setItem","navigator","publicUrl","URL","process","env","PUBLIC_URL","origin","serviceWorkerName","NODE_ENV","swUrl","registerValidSW","checkValidServiceWorker","serviceWorker","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","clientUpdate","error","subscribeNotifications","ready","pushManager","getSubscription","pushSubscription","unsubscribe","subscribe","userVisibleOnly","JSON","stringify","endpoint","p256dh_base64url","getKey","auth_base64url","authorizationState","deviceToken","send","device_token","other_user_ids","result","enableSound","fetch","response","status","headers","get","indexOf","unregister","reload","update"],"mappings":"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","sourcesContent":["/*\n *  Copyright (c) 2018-present, Evgeny Nadymov\n *\n * This source code is licensed under the GPL v.3.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { arrayBufferToBase64, isAuthorizationReady } from './Utils/Common';\nimport { OPTIMIZATIONS_FIRST_START } from './Constants';\nimport ApplicationStore from './Stores/ApplicationStore';\nimport NotificationStore from './Stores/NotificationStore';\nimport TdLibController from './Controllers/TdLibController';\n\n// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost =\n    //false;\n    Boolean(\n        window.location.hostname === 'localhost' ||\n            // [::1] is the IPv6 localhost address.\n            window.location.hostname === '[::1]' ||\n            // 127.0.0.1/8 is considered localhost for IPv4.\n            window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n    );\n\nexport default async function register() {\n    console.log('[SW] Register');\n\n    if (OPTIMIZATIONS_FIRST_START) {\n        localStorage.setItem('register', 'true');\n    }\n\n    if ('serviceWorker' in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n            return;\n        }\n\n        const serviceWorkerName =\n            process.env.NODE_ENV === 'production' ? 'service-worker.js' : 'custom-service-worker.js';\n        const swUrl = `${process.env.PUBLIC_URL}/${serviceWorkerName}`;\n        console.log(`[SW] Service worker url: ${swUrl}`);\n\n        if (!isLocalhost) {\n            // Is not local host. Just register service worker\n            await registerValidSW(swUrl);\n        } else {\n            // This is running on localhost. Lets check if a service worker still exists or not.\n            await checkValidServiceWorker(swUrl);\n        }\n    }\n}\n\nasync function registerValidSW(swUrl) {\n    console.log('[SW] RegisterValidSW');\n    try {\n        const registration = await navigator.serviceWorker.register(swUrl);\n        registration.onupdatefound = () => {\n            const installingWorker = registration.installing;\n            installingWorker.onstatechange = () => {\n                if (installingWorker.state === 'installed') {\n                    if (navigator.serviceWorker.controller) {\n                        // At this point, the old content will have been purged and\n                        // the fresh content will have been added to the cache.\n                        // It's the perfect time to display a \"New content is\n                        // available; please refresh.\" message in your web app.\n                        console.log('[SW] New content is available; please refresh.');\n\n                        TdLibController.clientUpdate({ '@type': 'clientUpdateNewContentAvailable' });\n                    } else {\n                        // At this point, everything has been precached.\n                        // It's the perfect time to display a\n                        // \"Content is cached for offline use.\" message.\n                        console.log('[SW] Content is cached for offline use.');\n                    }\n                }\n            };\n        };\n    } catch (error) {\n        console.error('[SW] Error during service worker registration: ', error);\n    }\n}\n\nexport async function subscribeNotifications() {\n    try {\n        const registration = await navigator.serviceWorker.ready;\n\n        let pushSubscription = await registration.pushManager.getSubscription();\n        if (pushSubscription) await pushSubscription.unsubscribe();\n\n        pushSubscription = await registration.pushManager.subscribe({ userVisibleOnly: true });\n        console.log('[SW] Received push subscription: ', JSON.stringify(pushSubscription));\n\n        const { endpoint } = pushSubscription;\n        const p256dh_base64url = arrayBufferToBase64(pushSubscription.getKey('p256dh'));\n        const auth_base64url = arrayBufferToBase64(pushSubscription.getKey('auth'));\n\n        if (endpoint && p256dh_base64url && auth_base64url) {\n            const { authorizationState } = ApplicationStore;\n            if (isAuthorizationReady(authorizationState)) {\n                const deviceToken = {\n                    '@type': 'deviceTokenWebPush',\n                    endpoint,\n                    p256dh_base64url,\n                    auth_base64url\n                };\n                console.log('[SW] registerDevice', deviceToken);\n                const result = await TdLibController.send({\n                    '@type': 'registerDevice',\n                    device_token: deviceToken,\n                    other_user_ids: []\n                });\n                console.log('[SW] registerDevice result', result);\n            }\n        }\n    } catch (error) {\n        console.error('[SW] Error during service worker push subscription: ', error);\n        NotificationStore.enableSound = true;\n    }\n}\n\nasync function checkValidServiceWorker(swUrl) {\n    console.log('[SW] CheckValidServiceWorker');\n    // Check if the service worker can be found. If it can't reload the page.\n    try {\n        const response = await fetch(swUrl);\n\n        // Ensure service worker exists, and that we really are getting a JS file.\n        if (response.status === 404 || response.headers.get('content-type').indexOf('javascript') === -1) {\n            // No service worker found. Probably a different app. Reload the page.\n            const registration = await navigator.serviceWorker.ready;\n            await registration.unregister();\n\n            window.location.reload();\n        } else {\n            // Service worker found. Proceed as normal.\n            await registerValidSW(swUrl);\n        }\n    } catch (error) {\n        console.log('[SW] No internet connection found. App is running in offline mode.');\n    }\n}\n\nexport async function unregister() {\n    if ('serviceWorker' in navigator) {\n        const registration = await navigator.serviceWorker.ready;\n\n        await registration.unregister();\n    }\n}\n\nexport async function update() {\n    if ('serviceWorker' in navigator) {\n        const registration = await navigator.serviceWorker.ready;\n\n        await registration.update();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}