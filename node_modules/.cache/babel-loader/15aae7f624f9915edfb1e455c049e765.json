{"ast":null,"code":"import _toConsumableArray from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/*\n *  Copyright (c) 2018-present, Evgeny Nadymov\n *\n * This source code is licensed under the GPL v.3.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport EventEmitter from './EventEmitter';\nimport { debounce } from '../Utils/Common';\nimport CacheManager from '../Workers/CacheManager';\nimport BasicGroupStore from './BasicGroupStore';\nimport ChatStore from './ChatStore';\nimport FileStore from './FileStore';\nimport MessageStore from './MessageStore';\nimport OptionStore from './OptionStore';\nimport SupergroupStore from './SupergroupStore';\nimport UserStore from './UserStore';\nimport TdLibController from '../Controllers/TdLibController';\n\nvar CacheStore =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(CacheStore, _EventEmitter);\n\n  function CacheStore() {\n    var _this;\n\n    _classCallCheck(this, CacheStore);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CacheStore).call(this));\n\n    _this.reset = function () {\n      _this.chatIds = [];\n      _this.cache = null;\n      _this.contacts = null;\n    };\n\n    _this.onUpdate = function (update) {\n      switch (update['@type']) {\n        case 'updateAuthorizationState':\n          {\n            var authorization_state = update.authorization_state;\n            if (!authorization_state) break;\n\n            switch (authorization_state['@type']) {\n              case 'authorizationStateClosed':\n                {\n                  _this.reset();\n\n                  break;\n                }\n\n              case 'authorizationStateLoggingOut':\n              case 'authorizationStateWaitCode':\n              case 'authorizationStateWaitPhoneNumber':\n              case 'authorizationStateWaitPassword':\n              case 'authorizationStateWaitRegistration':\n                {\n                  CacheManager.remove('cache');\n                  CacheManager.remove('files');\n                  CacheManager.remove('contacts');\n                  break;\n                }\n            }\n\n            break;\n          }\n\n        default:\n          break;\n      }\n    };\n\n    _this.onClientUpdate = function (update) {\n      switch (update['@type']) {\n        case 'clientUpdateDialogsReady':\n          {\n            _this.clear();\n          }\n\n        default:\n          break;\n      }\n    };\n\n    _this.addTdLibListener = function () {\n      TdLibController.on('update', _this.onUpdate);\n      TdLibController.on('clientUpdate', _this.onClientUpdate);\n    };\n\n    _this.removeTdLibListener = function () {\n      TdLibController.off('update', _this.onUpdate);\n      TdLibController.off('clientUpdate', _this.onClientUpdate);\n    };\n\n    _this.reset();\n\n    _this.addTdLibListener();\n\n    _this.saveChatsInternal = debounce(_this.saveChatsInternal, 2000);\n    return _this;\n  }\n\n  _createClass(CacheStore, [{\n    key: \"loadCache\",\n    value: function () {\n      var _loadCache = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var promises, _ref, _ref2, cache, files;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // console.log('[cm] getChats start');\n                promises = [];\n                promises.push(CacheManager.load('cache').catch(function (error) {\n                  return null;\n                }));\n                promises.push(CacheManager.load('files').catch(function (error) {\n                  return null;\n                }));\n                _context.next = 5;\n                return Promise.all(promises);\n\n              case 5:\n                _ref = _context.sent;\n                _ref2 = _slicedToArray(_ref, 2);\n                cache = _ref2[0];\n                files = _ref2[1];\n                this.cache = cache;\n\n                if (this.cache) {\n                  this.cache.files = files || [];\n                } // console.log('[cm] getChats result', this.cache);\n\n\n                if (this.cache) {\n                  _context.next = 13;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", null);\n\n              case 13:\n                this.parseCache(this.cache);\n                return _context.abrupt(\"return\", this.cache);\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function loadCache() {\n        return _loadCache.apply(this, arguments);\n      }\n\n      return loadCache;\n    }()\n  }, {\n    key: \"parseCache\",\n    value: function parseCache(cache) {\n      if (!cache) return;\n      var chats = cache.chats,\n          archiveChats = cache.archiveChats,\n          users = cache.users,\n          basicGroups = cache.basicGroups,\n          supergroups = cache.supergroups,\n          files = cache.files,\n          options = cache.options;\n      console.log('[cache] parseCache', cache);\n      (files || []).filter(function (x) {\n        return Boolean(x);\n      }).forEach(function (_ref3) {\n        var id = _ref3.id,\n            url = _ref3.url;\n        FileStore.setDataUrl(id, url);\n      });\n      (users || []).forEach(function (x) {\n        UserStore.set(x);\n      });\n      (basicGroups || []).forEach(function (x) {\n        BasicGroupStore.set(x);\n      });\n      (supergroups || []).forEach(function (x) {\n        SupergroupStore.set(x);\n      });\n      (chats || []).concat(archiveChats || []).forEach(function (x) {\n        delete x.OutputTypingManager;\n        ChatStore.set(x);\n\n        if (x.photo) {\n          if (x.photo.small) FileStore.set(x.photo.small);\n          if (x.photo.big) FileStore.set(x.photo.big);\n        }\n\n        if (x.chat_list) {\n          ChatStore.updateChatChatList(x.id, x.chat_list);\n        }\n\n        if (x.last_message) {\n          MessageStore.set(x.last_message);\n        }\n      });\n      (options || []).forEach(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            id = _ref5[0],\n            option = _ref5[1];\n\n        OptionStore.set(id, option);\n      });\n    }\n  }, {\n    key: \"getCache\",\n    value: function getCache(chatIds, archiveChatIds) {\n      var fileMap = new Map();\n      var userMap = new Map();\n      var basicGroupMap = new Map();\n      var supergroupMap = new Map();\n      var chats = chatIds.map(function (x) {\n        return ChatStore.get(x);\n      });\n      var archiveChats = archiveChatIds.map(function (x) {\n        return ChatStore.get(x);\n      });\n      chats.concat(archiveChats).forEach(function (x) {\n        var photo = x.photo,\n            type = x.type,\n            last_message = x.last_message;\n\n        if (photo && photo.small) {\n          var id = photo.small.id;\n\n          if (id) {\n            var blob = FileStore.getBlob(id);\n\n            if (blob) {\n              fileMap.set(id, blob);\n            }\n          }\n        }\n\n        switch (type['@type']) {\n          case 'chatTypeBasicGroup':\n            {\n              var basicGroup = BasicGroupStore.get(type.basic_group_id);\n\n              if (basicGroup) {\n                basicGroupMap.set(basicGroup.id, basicGroup);\n              }\n            }\n\n          case 'chatTypePrivate':\n          case 'chatTypeSecret':\n            {\n              var user = UserStore.get(type.user_id);\n\n              if (user) {\n                userMap.set(user.id, user);\n              }\n            }\n\n          case 'chatTypeSupergroup':\n            {\n              var supergroup = SupergroupStore.get(type.supergroup_id);\n\n              if (supergroup) {\n                supergroupMap.set(supergroup.id, supergroup);\n              }\n            }\n        }\n\n        if (last_message) {\n          var sender_user_id = last_message.sender_user_id;\n\n          if (sender_user_id) {\n            var _user = UserStore.get(sender_user_id);\n\n            if (_user) {\n              userMap.set(_user.id, _user);\n            }\n          }\n        }\n      });\n      return {\n        chats: chats,\n        archiveChats: archiveChats,\n        users: _toConsumableArray(userMap.values()),\n        basicGroups: _toConsumableArray(basicGroupMap.values()),\n        supergroups: _toConsumableArray(supergroupMap.values()),\n        files: _toConsumableArray(fileMap.entries()),\n        options: _toConsumableArray(OptionStore.items.entries())\n      };\n    }\n  }, {\n    key: \"saveChats\",\n    value: function saveChats(chatIds, archiveChatIds) {\n      this.chatIds = chatIds;\n      this.archiveChatIds = archiveChatIds;\n      this.saveChatsInternal();\n    }\n  }, {\n    key: \"saveChatsInternal\",\n    value: function () {\n      var _saveChatsInternal = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        var cache, files, promises, results;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // console.log('[cm] saveChatsInternal', this.chatIds, this.archiveChatIds);\n                cache = this.getCache(this.chatIds, this.archiveChatIds);\n                files = cache.files;\n                cache.files = []; // console.log('[cm] save cache', cache);\n\n                _context2.next = 5;\n                return CacheManager.save('cache', cache);\n\n              case 5:\n                promises = [];\n                files.forEach(function (x) {\n                  var _x = _slicedToArray(x, 2),\n                      id = _x[0],\n                      blob = _x[1];\n\n                  promises.push(new Promise(function (resolve, reject) {\n                    var fileReader = new FileReader();\n                    fileReader.readAsDataURL(blob);\n\n                    fileReader.onload = function (e) {\n                      resolve({\n                        id: id,\n                        url: e.target.result\n                      });\n                    };\n\n                    fileReader.onerror = function (e) {\n                      resolve(null);\n                    };\n                  }));\n                }); // console.log('[cm] save files start', files);\n\n                _context2.next = 9;\n                return Promise.all(promises);\n\n              case 9:\n                results = _context2.sent;\n                _context2.next = 12;\n                return CacheManager.save('files', results);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function saveChatsInternal() {\n        return _saveChatsInternal.apply(this, arguments);\n      }\n\n      return saveChatsInternal;\n    }()\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this.cache) {\n        var files = this.cache.files;\n        files.filter(function (x) {\n          return Boolean(x);\n        }).forEach(function (_ref6) {\n          var id = _ref6.id,\n              url = _ref6.url;\n          FileStore.deleteDataUrl(id);\n        });\n      }\n    }\n  }]);\n\n  return CacheStore;\n}(EventEmitter);\n\nvar store = new CacheStore();\nwindow.cache = store;\nexport default store;","map":{"version":3,"sources":["/Users/wubenqi/nebula-chat/telegram-react/src/Stores/CacheStore.js"],"names":["EventEmitter","debounce","CacheManager","BasicGroupStore","ChatStore","FileStore","MessageStore","OptionStore","SupergroupStore","UserStore","TdLibController","CacheStore","reset","chatIds","cache","contacts","onUpdate","update","authorization_state","remove","onClientUpdate","clear","addTdLibListener","on","removeTdLibListener","off","saveChatsInternal","promises","push","load","catch","error","Promise","all","files","parseCache","chats","archiveChats","users","basicGroups","supergroups","options","console","log","filter","x","Boolean","forEach","id","url","setDataUrl","set","concat","OutputTypingManager","photo","small","big","chat_list","updateChatChatList","last_message","option","archiveChatIds","fileMap","Map","userMap","basicGroupMap","supergroupMap","map","get","type","blob","getBlob","basicGroup","basic_group_id","user","user_id","supergroup","supergroup_id","sender_user_id","values","entries","items","getCache","save","resolve","reject","fileReader","FileReader","readAsDataURL","onload","e","target","result","onerror","results","deleteDataUrl","store","window"],"mappings":"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","sourcesContent":["/*\n *  Copyright (c) 2018-present, Evgeny Nadymov\n *\n * This source code is licensed under the GPL v.3.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport EventEmitter from './EventEmitter';\nimport { debounce } from '../Utils/Common';\nimport CacheManager from '../Workers/CacheManager';\nimport BasicGroupStore from './BasicGroupStore';\nimport ChatStore from './ChatStore';\nimport FileStore from './FileStore';\nimport MessageStore from './MessageStore';\nimport OptionStore from './OptionStore';\nimport SupergroupStore from './SupergroupStore';\nimport UserStore from './UserStore';\nimport TdLibController from '../Controllers/TdLibController';\n\nclass CacheStore extends EventEmitter {\n    constructor() {\n        super();\n\n        this.reset();\n\n        this.addTdLibListener();\n\n        this.saveChatsInternal = debounce(this.saveChatsInternal, 2000);\n    }\n\n    reset = () => {\n        this.chatIds = [];\n        this.cache = null;\n        this.contacts = null;\n    };\n\n    onUpdate = update => {\n        switch (update['@type']) {\n            case 'updateAuthorizationState': {\n                const { authorization_state } = update;\n                if (!authorization_state) break;\n\n                switch (authorization_state['@type']) {\n                    case 'authorizationStateClosed': {\n                        this.reset();\n                        break;\n                    }\n                    case 'authorizationStateLoggingOut':\n                    case 'authorizationStateWaitCode':\n                    case 'authorizationStateWaitPhoneNumber':\n                    case 'authorizationStateWaitPassword':\n                    case 'authorizationStateWaitRegistration': {\n                        CacheManager.remove('cache');\n                        CacheManager.remove('files');\n                        CacheManager.remove('contacts');\n                        break;\n                    }\n                }\n\n                break;\n            }\n            default:\n                break;\n        }\n    };\n\n    onClientUpdate = update => {\n        switch (update['@type']) {\n            case 'clientUpdateDialogsReady': {\n                this.clear();\n            }\n            default:\n                break;\n        }\n    };\n\n    addTdLibListener = () => {\n        TdLibController.on('update', this.onUpdate);\n        TdLibController.on('clientUpdate', this.onClientUpdate);\n    };\n\n    removeTdLibListener = () => {\n        TdLibController.off('update', this.onUpdate);\n        TdLibController.off('clientUpdate', this.onClientUpdate);\n    };\n\n    async loadCache() {\n        // console.log('[cm] getChats start');\n        const promises = [];\n        promises.push(CacheManager.load('cache').catch(error => null));\n        promises.push(CacheManager.load('files').catch(error => null));\n        const [cache, files] = await Promise.all(promises);\n        this.cache = cache;\n        if (this.cache) {\n            this.cache.files = files || [];\n        }\n        // console.log('[cm] getChats result', this.cache);\n        if (!this.cache) return null;\n\n        this.parseCache(this.cache);\n\n        return this.cache;\n    }\n\n    parseCache(cache) {\n        if (!cache) return;\n\n        const { chats, archiveChats, users, basicGroups, supergroups, files, options } = cache;\n        console.log('[cache] parseCache', cache);\n\n        (files || []).filter(x => Boolean(x)).forEach(({ id, url }) => {\n            FileStore.setDataUrl(id, url);\n        });\n\n        (users || []).forEach(x => {\n            UserStore.set(x);\n        });\n\n        (basicGroups || []).forEach(x => {\n            BasicGroupStore.set(x);\n        });\n\n        (supergroups || []).forEach(x => {\n            SupergroupStore.set(x);\n        });\n\n        (chats || []).concat(archiveChats || []).forEach(x => {\n            delete x.OutputTypingManager;\n\n            ChatStore.set(x);\n            if (x.photo) {\n                if (x.photo.small) FileStore.set(x.photo.small);\n                if (x.photo.big) FileStore.set(x.photo.big);\n            }\n            if (x.chat_list) {\n                ChatStore.updateChatChatList(x.id, x.chat_list);\n            }\n            if (x.last_message) {\n                MessageStore.set(x.last_message);\n            }\n        });\n\n        (options || []).forEach(([id, option]) => {\n            OptionStore.set(id, option);\n        });\n    }\n\n    getCache(chatIds, archiveChatIds) {\n        const fileMap = new Map();\n        const userMap = new Map();\n        const basicGroupMap = new Map();\n        const supergroupMap = new Map();\n        const chats = chatIds.map(x => ChatStore.get(x));\n        const archiveChats = archiveChatIds.map(x => ChatStore.get(x));\n        chats.concat(archiveChats).forEach(x => {\n            const { photo, type, last_message } = x;\n            if (photo && photo.small) {\n                const { id } = photo.small;\n                if (id) {\n                    const blob = FileStore.getBlob(id);\n                    if (blob) {\n                        fileMap.set(id, blob);\n                    }\n                }\n            }\n\n            switch (type['@type']) {\n                case 'chatTypeBasicGroup': {\n                    const basicGroup = BasicGroupStore.get(type.basic_group_id);\n                    if (basicGroup) {\n                        basicGroupMap.set(basicGroup.id, basicGroup);\n                    }\n                }\n                case 'chatTypePrivate':\n                case 'chatTypeSecret': {\n                    const user = UserStore.get(type.user_id);\n                    if (user) {\n                        userMap.set(user.id, user);\n                    }\n                }\n                case 'chatTypeSupergroup': {\n                    const supergroup = SupergroupStore.get(type.supergroup_id);\n                    if (supergroup) {\n                        supergroupMap.set(supergroup.id, supergroup);\n                    }\n                }\n            }\n\n            if (last_message) {\n                const { sender_user_id } = last_message;\n                if (sender_user_id) {\n                    const user = UserStore.get(sender_user_id);\n                    if (user) {\n                        userMap.set(user.id, user);\n                    }\n                }\n            }\n        });\n\n        return {\n            chats,\n            archiveChats,\n            users: [...userMap.values()],\n            basicGroups: [...basicGroupMap.values()],\n            supergroups: [...supergroupMap.values()],\n            files: [...fileMap.entries()],\n            options: [...OptionStore.items.entries()]\n        };\n    }\n\n    saveChats(chatIds, archiveChatIds) {\n        this.chatIds = chatIds;\n        this.archiveChatIds = archiveChatIds;\n        this.saveChatsInternal();\n    }\n\n    async saveChatsInternal() {\n        // console.log('[cm] saveChatsInternal', this.chatIds, this.archiveChatIds);\n        const cache = this.getCache(this.chatIds, this.archiveChatIds);\n        const files = cache.files;\n        cache.files = [];\n        // console.log('[cm] save cache', cache);\n        await CacheManager.save('cache', cache);\n\n        const promises = [];\n        files.forEach(x => {\n            const [id, blob] = x;\n            promises.push(\n                new Promise((resolve, reject) => {\n                    const fileReader = new FileReader();\n                    fileReader.readAsDataURL(blob);\n                    fileReader.onload = e => {\n                        resolve({ id, url: e.target.result });\n                    };\n                    fileReader.onerror = e => {\n                        resolve(null);\n                    };\n                })\n            );\n        });\n        // console.log('[cm] save files start', files);\n        const results = await Promise.all(promises);\n        // console.log('[cm] save files', results);\n        await CacheManager.save('files', results);\n    }\n\n    clear() {\n        if (this.cache) {\n            const { files } = this.cache;\n\n            files.filter(x => Boolean(x)).forEach(({ id, url }) => {\n                FileStore.deleteDataUrl(id);\n            });\n        }\n    }\n}\n\nconst store = new CacheStore();\nwindow.cache = store;\nexport default store;\n"]},"metadata":{},"sourceType":"module"}